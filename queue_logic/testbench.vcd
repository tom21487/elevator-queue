$date
	Sun Jul 30 12:21:47 2023
$end
$version
	Icarus Verilog
$end
$timescale
	10ps
$end
$scope module testbench $end
$var wire 12 ! next_queue_sub [11:0] $end
$var wire 3 " next_tail_sub [2:0] $end
$var wire 1 # stop_at_pos_lvl $end
$var reg 2 $ pos_lvl [1:0] $end
$var reg 1 % pressed_en $end
$var reg 2 & pressed_lvl [1:0] $end
$var reg 1 ' pressed_lvl_in_queue $end
$var reg 12 ( queue [11:0] $end
$var reg 3 ) tail [2:0] $end
$scope module uut $end
$var wire 1 * add_new_lvl $end
$var wire 12 + next_queue_add [11:0] $end
$var wire 12 , next_queue_sub [11:0] $end
$var wire 3 - next_tail_add [2:0] $end
$var wire 3 . next_tail_sub [2:0] $end
$var wire 2 / pos_lvl [1:0] $end
$var wire 1 % pressed_en $end
$var wire 2 0 pressed_lvl [1:0] $end
$var wire 1 ' pressed_lvl_in_queue $end
$var wire 12 1 queue [11:0] $end
$var wire 1 2 shift0 $end
$var wire 1 3 shift3 $end
$var wire 1 # stop_at_pos_lvl $end
$var wire 3 4 tail [2:0] $end
$scope module nqa $end
$var wire 1 * add_new_lvl $end
$var wire 12 5 next_queue_add [11:0] $end
$var wire 2 6 pressed_lvl [1:0] $end
$var wire 12 7 queue [11:0] $end
$var wire 3 8 tail [2:0] $end
$upscope $end
$scope module nqs $end
$var wire 12 9 next_queue_add [11:0] $end
$var wire 12 : next_queue_sub [11:0] $end
$var wire 3 ; next_tail_add [2:0] $end
$var wire 2 < pos_lvl [1:0] $end
$var wire 1 2 shift0 $end
$var wire 1 3 shift3 $end
$var wire 1 # stop_at_pos_lvl $end
$upscope $end
$scope module nta $end
$var wire 1 * add_new_lvl $end
$var wire 3 = next_tail_add [2:0] $end
$var wire 3 > tail [2:0] $end
$upscope $end
$scope module nts $end
$var wire 3 ? next_tail_add [2:0] $end
$var wire 3 @ next_tail_sub [2:0] $end
$var wire 1 3 shift3 $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
b0 5
b0 4
03
z2
b0 1
b0 0
b0 /
b0 .
b0 -
b0 ,
b0 +
0*
b0 )
b0 (
0'
b0 &
0%
b0 $
0#
b0 "
b0 !
$end
#1000000
